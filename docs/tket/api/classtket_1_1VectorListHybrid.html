<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tket: tket::VectorListHybrid&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetket.html">tket</a></li><li class="navelem"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtket_1_1VectorListHybrid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tket::VectorListHybrid&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>VectorListHybrid&lt;T&gt; combines some functionality of std::vector&lt;T&gt; and std::list&lt;T&gt;, with the following goals:  
 <a href="classtket_1_1VectorListHybrid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8d32b7ccea8fb3974a036d113ec135d2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtket_1_1tsa__internal_1_1VectorListHybridSkeleton.html#a5dc78dab75cded94e911f79e1dd1beae">tsa_internal::VectorListHybridSkeleton::Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a></td></tr>
<tr class="memdesc:a8d32b7ccea8fb3974a036d113ec135d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">NOTE: the ID is NOT necessarily an actual vector index; that's an implementation detail.  <a href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">More...</a><br /></td></tr>
<tr class="separator:a8d32b7ccea8fb3974a036d113ec135d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c6a87b6a6b7cce6400919687583c385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a7c6a87b6a6b7cce6400919687583c385">VectorListHybrid</a> ()</td></tr>
<tr class="separator:a7c6a87b6a6b7cce6400919687583c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a3400ddbb0fee0cf9da1d1aa5e6c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ab7a3400ddbb0fee0cf9da1d1aa5e6c70">clear</a> ()</td></tr>
<tr class="memdesc:ab7a3400ddbb0fee0cf9da1d1aa5e6c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical clear: doesn't actually delete the elements, just relabels them for reuse.  <a href="classtket_1_1VectorListHybrid.html#ab7a3400ddbb0fee0cf9da1d1aa5e6c70">More...</a><br /></td></tr>
<tr class="separator:ab7a3400ddbb0fee0cf9da1d1aa5e6c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b4f9c53d9eadb0bf2952a9abb4f8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ad5b4f9c53d9eadb0bf2952a9abb4f8d5">fast_clear</a> ()</td></tr>
<tr class="memdesc:ad5b4f9c53d9eadb0bf2952a9abb4f8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical clear: doesn't actually delete the elements, just relabels them for reuse.  <a href="classtket_1_1VectorListHybrid.html#ad5b4f9c53d9eadb0bf2952a9abb4f8d5">More...</a><br /></td></tr>
<tr class="separator:ad5b4f9c53d9eadb0bf2952a9abb4f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7451fe6504b746702e88d1fdbb3264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a3a7451fe6504b746702e88d1fdbb3264">reverse</a> ()</td></tr>
<tr class="memdesc:a3a7451fe6504b746702e88d1fdbb3264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like std::reverse, reverses the (logical) order of the elements.  <a href="classtket_1_1VectorListHybrid.html#a3a7451fe6504b746702e88d1fdbb3264">More...</a><br /></td></tr>
<tr class="separator:a3a7451fe6504b746702e88d1fdbb3264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc54f1f2617a6eba0f802fc31dbbd17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a7dc54f1f2617a6eba0f802fc31dbbd17">empty</a> () const</td></tr>
<tr class="separator:a7dc54f1f2617a6eba0f802fc31dbbd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add329e55d8d33d42b9a979d541b68498"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#add329e55d8d33d42b9a979d541b68498">size</a> () const</td></tr>
<tr class="memdesc:add329e55d8d33d42b9a979d541b68498"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of valid elements stored (not, of course, the actual internal number of elements, which is larger if some are waiting to be reused).  <a href="classtket_1_1VectorListHybrid.html#add329e55d8d33d42b9a979d541b68498">More...</a><br /></td></tr>
<tr class="separator:add329e55d8d33d42b9a979d541b68498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ff36bbb8c4eae1a5c3c61b33808da2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ad6ff36bbb8c4eae1a5c3c61b33808da2">push_back</a> (const T &amp;elem)</td></tr>
<tr class="memdesc:ad6ff36bbb8c4eae1a5c3c61b33808da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly like std::vector push_back.  <a href="classtket_1_1VectorListHybrid.html#ad6ff36bbb8c4eae1a5c3c61b33808da2">More...</a><br /></td></tr>
<tr class="separator:ad6ff36bbb8c4eae1a5c3c61b33808da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e028a87a59315d0f3d804b3fc99323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ac7e028a87a59315d0f3d804b3fc99323">emplace_back</a> ()</td></tr>
<tr class="memdesc:ac7e028a87a59315d0f3d804b3fc99323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like push_back, creates a new element after the current back, but returns the ID for the new element (which of course might not really be new; it is for reuse - it may be an old T object).  <a href="classtket_1_1VectorListHybrid.html#ac7e028a87a59315d0f3d804b3fc99323">More...</a><br /></td></tr>
<tr class="separator:ac7e028a87a59315d0f3d804b3fc99323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1231d4a39b387c120068cc803414bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#af1231d4a39b387c120068cc803414bf1">pop_back</a> ()</td></tr>
<tr class="memdesc:af1231d4a39b387c120068cc803414bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element at the back, but no checks for validity.  <a href="classtket_1_1VectorListHybrid.html#af1231d4a39b387c120068cc803414bf1">More...</a><br /></td></tr>
<tr class="separator:af1231d4a39b387c120068cc803414bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2522b963937f4cc2f9ccf5564fd31660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a2522b963937f4cc2f9ccf5564fd31660">push_front</a> (const T &amp;elem)</td></tr>
<tr class="memdesc:a2522b963937f4cc2f9ccf5564fd31660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like push_back, but instead inserts the new element before the existing front element (so that it becomes the new front).  <a href="classtket_1_1VectorListHybrid.html#a2522b963937f4cc2f9ccf5564fd31660">More...</a><br /></td></tr>
<tr class="separator:a2522b963937f4cc2f9ccf5564fd31660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75cb672e749991521b49cd2e0f64774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#aa75cb672e749991521b49cd2e0f64774">emplace_front</a> ()</td></tr>
<tr class="memdesc:aa75cb672e749991521b49cd2e0f64774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classtket_1_1VectorListHybrid.html#ac7e028a87a59315d0f3d804b3fc99323" title="Like push_back, creates a new element after the current back, but returns the ID for the new element ...">emplace_back()</a>, but creates the new element at the front, like push_front.  <a href="classtket_1_1VectorListHybrid.html#aa75cb672e749991521b49cd2e0f64774">More...</a><br /></td></tr>
<tr class="separator:aa75cb672e749991521b49cd2e0f64774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bead1695c11a4f1cd42b9f19054eae5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a7bead1695c11a4f1cd42b9f19054eae5">pop_front</a> ()</td></tr>
<tr class="memdesc:a7bead1695c11a4f1cd42b9f19054eae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element at the front, but no checks for validity.  <a href="classtket_1_1VectorListHybrid.html#a7bead1695c11a4f1cd42b9f19054eae5">More...</a><br /></td></tr>
<tr class="separator:a7bead1695c11a4f1cd42b9f19054eae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4883a24beabc7af1c1feb518e23445d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a4883a24beabc7af1c1feb518e23445d6">insert_after</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id)</td></tr>
<tr class="memdesc:a4883a24beabc7af1c1feb518e23445d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element after the existing one (not checked).  <a href="classtket_1_1VectorListHybrid.html#a4883a24beabc7af1c1feb518e23445d6">More...</a><br /></td></tr>
<tr class="separator:a4883a24beabc7af1c1feb518e23445d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a3c816d411378fa631c60d4fb98af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#afd4a3c816d411378fa631c60d4fb98af">insert_before</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id)</td></tr>
<tr class="memdesc:afd4a3c816d411378fa631c60d4fb98af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new element before the existing one (not checked).  <a href="classtket_1_1VectorListHybrid.html#afd4a3c816d411378fa631c60d4fb98af">More...</a><br /></td></tr>
<tr class="separator:afd4a3c816d411378fa631c60d4fb98af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413fc5ebb07d1a28d4bf52a5defb1dc9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9">back</a> ()</td></tr>
<tr class="memdesc:a413fc5ebb07d1a28d4bf52a5defb1dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like std::vector <a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9" title="Just like std::vector back().">back()</a>.  <a href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9">More...</a><br /></td></tr>
<tr class="separator:a413fc5ebb07d1a28d4bf52a5defb1dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd08e5fdf68236f922cf3284a998517"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a8bd08e5fdf68236f922cf3284a998517">front</a> ()</td></tr>
<tr class="memdesc:a8bd08e5fdf68236f922cf3284a998517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element for reuse; must exist!  <a href="classtket_1_1VectorListHybrid.html#a8bd08e5fdf68236f922cf3284a998517">More...</a><br /></td></tr>
<tr class="separator:a8bd08e5fdf68236f922cf3284a998517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f7cd93373975a96386d9d12f475322"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ab3f7cd93373975a96386d9d12f475322">at</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id)</td></tr>
<tr class="memdesc:ab3f7cd93373975a96386d9d12f475322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the stored element at the existing ID (not checked!)  <a href="classtket_1_1VectorListHybrid.html#ab3f7cd93373975a96386d9d12f475322">More...</a><br /></td></tr>
<tr class="separator:ab3f7cd93373975a96386d9d12f475322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0598a3333b2e56abde8e4b9f1fb7ce09"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a0598a3333b2e56abde8e4b9f1fb7ce09">at</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>) const</td></tr>
<tr class="memdesc:a0598a3333b2e56abde8e4b9f1fb7ce09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the stored element at the existing ID (not checked!)  <a href="classtket_1_1VectorListHybrid.html#a0598a3333b2e56abde8e4b9f1fb7ce09">More...</a><br /></td></tr>
<tr class="separator:a0598a3333b2e56abde8e4b9f1fb7ce09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8983379fe4906eb522ae9df265c0bc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#aee8983379fe4906eb522ae9df265c0bc">next</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id) const</td></tr>
<tr class="memdesc:aee8983379fe4906eb522ae9df265c0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element ID after the given one (which MUST be valid), or a null ID if we're already at the back.  <a href="classtket_1_1VectorListHybrid.html#aee8983379fe4906eb522ae9df265c0bc">More...</a><br /></td></tr>
<tr class="separator:aee8983379fe4906eb522ae9df265c0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443373f414ff79a6f4bd6f269f972d86"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a443373f414ff79a6f4bd6f269f972d86">next</a> (std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; id) const</td></tr>
<tr class="memdesc:a443373f414ff79a6f4bd6f269f972d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the element after the given one.  <a href="classtket_1_1VectorListHybrid.html#a443373f414ff79a6f4bd6f269f972d86">More...</a><br /></td></tr>
<tr class="separator:a443373f414ff79a6f4bd6f269f972d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b8075762ae9f019588a9b429a06db4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#aa7b8075762ae9f019588a9b429a06db4">previous</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id) const</td></tr>
<tr class="memdesc:aa7b8075762ae9f019588a9b429a06db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like next.  <a href="classtket_1_1VectorListHybrid.html#aa7b8075762ae9f019588a9b429a06db4">More...</a><br /></td></tr>
<tr class="separator:aa7b8075762ae9f019588a9b429a06db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f30beef5ae76dd4f4fc6b38e2e0b0cd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a6f30beef5ae76dd4f4fc6b38e2e0b0cd">back_id</a> () const</td></tr>
<tr class="memdesc:a6f30beef5ae76dd4f4fc6b38e2e0b0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the <a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9" title="Just like std::vector back().">back()</a> element, if it exists.  <a href="classtket_1_1VectorListHybrid.html#a6f30beef5ae76dd4f4fc6b38e2e0b0cd">More...</a><br /></td></tr>
<tr class="separator:a6f30beef5ae76dd4f4fc6b38e2e0b0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56e3a90afbb5cd49bfe009e225c5aa"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ade56e3a90afbb5cd49bfe009e225c5aa">front_id</a> () const</td></tr>
<tr class="memdesc:ade56e3a90afbb5cd49bfe009e225c5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of the <a class="el" href="classtket_1_1VectorListHybrid.html#a8bd08e5fdf68236f922cf3284a998517" title="Retrieve the element for reuse; must exist!">front()</a> element, if it exists.  <a href="classtket_1_1VectorListHybrid.html#ade56e3a90afbb5cd49bfe009e225c5aa">More...</a><br /></td></tr>
<tr class="separator:ade56e3a90afbb5cd49bfe009e225c5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab415404b6d2f03d0cd3739becfdbc903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ab415404b6d2f03d0cd3739becfdbc903">erase</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id)</td></tr>
<tr class="memdesc:ab415404b6d2f03d0cd3739becfdbc903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the element with that ID, whilst updating other links (the ID must actually exist).  <a href="classtket_1_1VectorListHybrid.html#ab415404b6d2f03d0cd3739becfdbc903">More...</a><br /></td></tr>
<tr class="separator:ab415404b6d2f03d0cd3739becfdbc903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f084ded69781a9c170d2c1812e5b92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a5f084ded69781a9c170d2c1812e5b92a">erase_interval</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id, size_t number_of_elements)</td></tr>
<tr class="memdesc:a5f084ded69781a9c170d2c1812e5b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting with the given ID, erase the given number of elements.  <a href="classtket_1_1VectorListHybrid.html#a5f084ded69781a9c170d2c1812e5b92a">More...</a><br /></td></tr>
<tr class="separator:a5f084ded69781a9c170d2c1812e5b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1fec7ccf0b67b4a7578a1218d557d6"><td class="memTemplParams" colspan="2">template&lt;class CIter &gt; </td></tr>
<tr class="memitem:a2e1fec7ccf0b67b4a7578a1218d557d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtket_1_1OverwriteIntervalResult.html">OverwriteIntervalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a2e1fec7ccf0b67b4a7578a1218d557d6">overwrite_interval</a> (<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id, const CIter &amp;new_elements_cbegin, const CIter &amp;new_elements_cend)</td></tr>
<tr class="memdesc:a2e1fec7ccf0b67b4a7578a1218d557d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting with the given ID, and given cbegin, cend iterators to a container of T objects, overwrite whatever T objects are currently stored in the list with the new T objects.  <a href="classtket_1_1VectorListHybrid.html#a2e1fec7ccf0b67b4a7578a1218d557d6">More...</a><br /></td></tr>
<tr class="separator:a2e1fec7ccf0b67b4a7578a1218d557d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aa252191d79bc46ae98febb7c9c9e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a68aa252191d79bc46ae98febb7c9c9e2">to_vector</a> () const</td></tr>
<tr class="memdesc:a68aa252191d79bc46ae98febb7c9c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ordinary vector of the data (in the correct order, maybe not the same as the internal storage order of course).  <a href="classtket_1_1VectorListHybrid.html#a68aa252191d79bc46ae98febb7c9c9e2">More...</a><br /></td></tr>
<tr class="separator:a68aa252191d79bc46ae98febb7c9c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c71e7bbfbbedac81662feff4e11550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#ab0c71e7bbfbbedac81662feff4e11550">append_to_vector</a> (std::vector&lt; T &gt; &amp;vect) const</td></tr>
<tr class="memdesc:ab0c71e7bbfbbedac81662feff4e11550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doesn't clear the vector, but copies all elements to the end of it.  <a href="classtket_1_1VectorListHybrid.html#ab0c71e7bbfbbedac81662feff4e11550">More...</a><br /></td></tr>
<tr class="separator:ab0c71e7bbfbbedac81662feff4e11550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6f7bc5c68bb1c651d440059bc1c83f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a6e6f7bc5c68bb1c651d440059bc1c83f">debug_str</a> () const</td></tr>
<tr class="memdesc:a6e6f7bc5c68bb1c651d440059bc1c83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only for debugging purposes.  <a href="classtket_1_1VectorListHybrid.html#a6e6f7bc5c68bb1c651d440059bc1c83f">More...</a><br /></td></tr>
<tr class="separator:a6e6f7bc5c68bb1c651d440059bc1c83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2351f510c5e6cdcc9bd901c7e6bfd235"><td class="memTemplParams" colspan="2">template&lt;class CIter &gt; </td></tr>
<tr class="memitem:a2351f510c5e6cdcc9bd901c7e6bfd235"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtket_1_1OverwriteIntervalResult.html">OverwriteIntervalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#a2351f510c5e6cdcc9bd901c7e6bfd235">overwrite_interval</a> (typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> id, const CIter &amp;new_elements_cbegin, const CIter &amp;new_elements_cend)</td></tr>
<tr class="separator:a2351f510c5e6cdcc9bd901c7e6bfd235"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af225d4fb58118bf1df830b36e344dcb5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1VectorListHybrid.html#af225d4fb58118bf1df830b36e344dcb5">get_invalid_id</a> ()</td></tr>
<tr class="memdesc:af225d4fb58118bf1df830b36e344dcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an ID which is guaranteed NEVER to be valid.  <a href="classtket_1_1VectorListHybrid.html#af225d4fb58118bf1df830b36e344dcb5">More...</a><br /></td></tr>
<tr class="separator:af225d4fb58118bf1df830b36e344dcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class tket::VectorListHybrid&lt; T &gt;</h3>

<p>VectorListHybrid&lt;T&gt; combines some functionality of std::vector&lt;T&gt; and std::list&lt;T&gt;, with the following goals: </p>
<p>Objects are stored internally inside a std::vector.</p>
<p>UNLIKE STL linked lists: erasure/insertion does NOT cause dynamic memory allocation/deallocation (except when more space is needed, in which case a vector reallocation takes place).</p>
<p>All operations are O(1), except insertions which are amortised O(1) (because a vector reallocation may be needed for more storage space).</p>
<p>Objects are not actually destroyed, they are merely marked for later reuse. Thus this class is good when objects are expensive to construct, but cheap to reuse and clear, and will be reused many times. (E.g., imagine a std::vector&lt;std::vector&lt;A&gt;&gt; being repeatedly resized; all those inner std::vector&lt;A&gt; are repeatedly deallocated and reallocated).</p>
<p>Objects can be accessed at any position, via an ID (like a vector index).</p>
<p>Erasure/insertion does NOT invalidate other IDs, unless that element was erased (or the whole container cleared).</p>
<p>NOTE: "previous" and "next" directions, by analogy with std::vector, correspond to the logical order the elements are regarded to have, AS IF they sat in a vector which we iterated through in forwards order (which, of course, is unrelated to where they are actually stored internally). Thus, "next", "forward" moves go towards the BACK; "previous", "backward" moves go towards the FRONT. This should not confuse if we remember std::vector itself, with begin() and rbegin() iterators.</p>
<p>TODO: there are no O(log N) operations, and no checks for invalid indices. This could be achieved by wrapping this class and storing sets/maps of erased/inserted IDs, etc. etc. Then everything would become O(log N) or amortised O(log N) instead of O(1), but we'd also have complete checks.</p>
<p>TODO: this class should have its own tests. Right now it is only used in other things (SwapListOptimiser) which do have end-to-end tests, so it's quite reliable but not as reliable as it could be.</p>
<p>TODO: Once this is well tested, move it to Utils for wider use. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00074">74</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8d32b7ccea8fb3974a036d113ec135d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d32b7ccea8fb3974a036d113ec135d2">&#9670;&nbsp;</a></span>ID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtket_1_1tsa__internal_1_1VectorListHybridSkeleton.html#a5dc78dab75cded94e911f79e1dd1beae">tsa_internal::VectorListHybridSkeleton::Index</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NOTE: the ID is NOT necessarily an actual vector index; that's an implementation detail. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00079">79</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c6a87b6a6b7cce6400919687583c385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6a87b6a6b7cce6400919687583c385">&#9670;&nbsp;</a></span>VectorListHybrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00301">301</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0c71e7bbfbbedac81662feff4e11550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c71e7bbfbbedac81662feff4e11550">&#9670;&nbsp;</a></span>append_to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::append_to_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Doesn't clear the vector, but copies all elements to the end of it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>A vector, which will have all the valid elements in this object pushed back to it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00497">497</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ab3f7cd93373975a96386d9d12f475322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f7cd93373975a96386d9d12f475322">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the stored element at the existing ID (not checked!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00414">414</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a0598a3333b2e56abde8e4b9f1fb7ce09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0598a3333b2e56abde8e4b9f1fb7ce09">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the stored element at the existing ID (not checked!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00419">419</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a413fc5ebb07d1a28d4bf52a5defb1dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413fc5ebb07d1a28d4bf52a5defb1dc9">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just like std::vector <a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9" title="Just like std::vector back().">back()</a>. </p>
<p>Retrieve the element for reuse; must exist! </p><dl class="section return"><dt>Returns</dt><dd>A reference to the existing element at the back. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00404">404</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a6f30beef5ae76dd4f4fc6b38e2e0b0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f30beef5ae76dd4f4fc6b38e2e0b0cd">&#9670;&nbsp;</a></span>back_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::back_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ID of the <a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9" title="Just like std::vector back().">back()</a> element, if it exists. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the element at <a class="el" href="classtket_1_1VectorListHybrid.html#a413fc5ebb07d1a28d4bf52a5defb1dc9" title="Just like std::vector back().">back()</a>, or null if there is none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00443">443</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ab7a3400ddbb0fee0cf9da1d1aa5e6c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a3400ddbb0fee0cf9da1d1aa5e6c70">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical clear: doesn't actually delete the elements, just relabels them for reuse. </p>
<p>Time O(N). After this, all data - even IDs - will behave AS IF it were a new object. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00318">318</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a6e6f7bc5c68bb1c651d440059bc1c83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6f7bc5c68bb1c651d440059bc1c83f">&#9670;&nbsp;</a></span>debug_str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::debug_str</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only for debugging purposes. </p>
<dl class="section return"><dt>Returns</dt><dd>A string giving further details of the internal data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00523">523</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ac7e028a87a59315d0f3d804b3fc99323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e028a87a59315d0f3d804b3fc99323">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::emplace_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like push_back, creates a new element after the current back, but returns the ID for the new element (which of course might not really be new; it is for reuse - it may be an old T object). </p>
<p>Of course the returned ID is the same as would be obtained from <a class="el" href="classtket_1_1VectorListHybrid.html#a6f30beef5ae76dd4f4fc6b38e2e0b0cd" title="The ID of the back() element, if it exists.">back_id()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The ID of the newly created (or reused) element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00348">348</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="aa75cb672e749991521b49cd2e0f64774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75cb672e749991521b49cd2e0f64774">&#9670;&nbsp;</a></span>emplace_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::emplace_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="classtket_1_1VectorListHybrid.html#ac7e028a87a59315d0f3d804b3fc99323" title="Like push_back, creates a new element after the current back, but returns the ID for the new element ...">emplace_back()</a>, but creates the new element at the front, like push_front. </p>
<p>However, returns the ID of the new object at the front. </p><dl class="section return"><dt>Returns</dt><dd>The ID of the newly created (or reused) element, at the front. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00369">369</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a7dc54f1f2617a6eba0f802fc31dbbd17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc54f1f2617a6eba0f802fc31dbbd17">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00332">332</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ab415404b6d2f03d0cd3739becfdbc903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab415404b6d2f03d0cd3739becfdbc903">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the element with that ID, whilst updating other links (the ID must actually exist). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the existing element to erase. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00455">455</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a5f084ded69781a9c170d2c1812e5b92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f084ded69781a9c170d2c1812e5b92a">&#9670;&nbsp;</a></span>erase_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::erase_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting with the given ID, erase the given number of elements. </p>
<p>Equivalent to looping with <a class="el" href="classtket_1_1VectorListHybrid.html#ab415404b6d2f03d0cd3739becfdbc903" title="Erase the element with that ID, whilst updating other links (the ID must actually exist).">erase()</a> and <a class="el" href="classtket_1_1VectorListHybrid.html#aee8983379fe4906eb522ae9df265c0bc" title="Get the element ID after the given one (which MUST be valid), or a null ID if we&#39;re already at the ba...">next()</a>, but more efficient. The list MUST contain enough elements to erase. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the initial existing element to erase. Must be valid. </td></tr>
    <tr><td class="paramname">number_of_elements</td><td>The number of elements to erase. The list MUST contain enough elements to be erased. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00460">460</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ad5b4f9c53d9eadb0bf2952a9abb4f8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b4f9c53d9eadb0bf2952a9abb4f8d5">&#9670;&nbsp;</a></span>fast_clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::fast_clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical clear: doesn't actually delete the elements, just relabels them for reuse. </p>
<p>Time O(1). After calling this function, IDs related to inserting/erasing elements may be different from those which would be obtained by the same sequence of operations on a new object. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00323">323</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a8bd08e5fdf68236f922cf3284a998517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd08e5fdf68236f922cf3284a998517">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the element for reuse; must exist! </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the existing element at the front. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00409">409</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ade56e3a90afbb5cd49bfe009e225c5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade56e3a90afbb5cd49bfe009e225c5aa">&#9670;&nbsp;</a></span>front_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::front_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ID of the <a class="el" href="classtket_1_1VectorListHybrid.html#a8bd08e5fdf68236f922cf3284a998517" title="Retrieve the element for reuse; must exist!">front()</a> element, if it exists. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the element at <a class="el" href="classtket_1_1VectorListHybrid.html#a8bd08e5fdf68236f922cf3284a998517" title="Retrieve the element for reuse; must exist!">front()</a>, or null if there is none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00449">449</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="af225d4fb58118bf1df830b36e344dcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af225d4fb58118bf1df830b36e344dcb5">&#9670;&nbsp;</a></span>get_invalid_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::get_invalid_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an ID which is guaranteed NEVER to be valid. </p>
<dl class="section return"><dt>Returns</dt><dd>an ID value guaranteed NEVER to be valid. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00304">304</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a4883a24beabc7af1c1feb518e23445d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4883a24beabc7af1c1feb518e23445d6">&#9670;&nbsp;</a></span>insert_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element after the existing one (not checked). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the new element, inserted immediately after (i.e., "next"; towards the BACK) of the given element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00390">390</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="afd4a3c816d411378fa631c60d4fb98af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4a3c816d411378fa631c60d4fb98af">&#9670;&nbsp;</a></span>insert_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new element before the existing one (not checked). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the new element, inserted immediately before (i.e., "previous"; towards the FRONT) of the given element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00397">397</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="aee8983379fe4906eb522ae9df265c0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8983379fe4906eb522ae9df265c0bc">&#9670;&nbsp;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element ID after the given one (which MUST be valid), or a null ID if we're already at the back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the element after it (towards the BACK), or null if it doesn't exist. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00424">424</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a443373f414ff79a6f4bd6f269f972d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443373f414ff79a6f4bd6f269f972d86">&#9670;&nbsp;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::next </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID of the element after the given one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element, OR null if none exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the element after it (towards the BACK), OR null if it doesn't exist, or no ID was specified. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00431">431</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a2e1fec7ccf0b67b4a7578a1218d557d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1fec7ccf0b67b4a7578a1218d557d6">&#9670;&nbsp;</a></span>overwrite_interval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class CIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtket_1_1OverwriteIntervalResult.html">OverwriteIntervalResult</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::overwrite_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CIter &amp;&#160;</td>
          <td class="paramname"><em>new_elements_cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CIter &amp;&#160;</td>
          <td class="paramname"><em>new_elements_cend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting with the given ID, and given cbegin, cend iterators to a container of T objects, overwrite whatever T objects are currently stored in the list with the new T objects. </p>
<p>The list MUST be big enough to allow overwriting all of them. The container of T objects MUST be nonempty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the initial existing T element to overwrite. Must be valid. </td></tr>
    <tr><td class="paramname">new_elements_cbegin</td><td>Const iterator to the start of a sequence of new T elements. </td></tr>
    <tr><td class="paramname">new_elements_cend</td><td>Const iterator to the cend of a sequence of new T elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the last T element that was overwritten; MUST be valid! </dd></dl>

</div>
</div>
<a id="a2351f510c5e6cdcc9bd901c7e6bfd235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2351f510c5e6cdcc9bd901c7e6bfd235">&#9670;&nbsp;</a></span>overwrite_interval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class CIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtket_1_1OverwriteIntervalResult.html">OverwriteIntervalResult</a> <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::overwrite_interval </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CIter &amp;&#160;</td>
          <td class="paramname"><em>new_elements_cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CIter &amp;&#160;</td>
          <td class="paramname"><em>new_elements_cend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00467">467</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="af1231d4a39b387c120068cc803414bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1231d4a39b387c120068cc803414bf1">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::pop_back</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the element at the back, but no checks for validity. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00358">358</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a7bead1695c11a4f1cd42b9f19054eae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bead1695c11a4f1cd42b9f19054eae5">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::pop_front</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase the element at the front, but no checks for validity. </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00379">379</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="aa7b8075762ae9f019588a9b429a06db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b8075762ae9f019588a9b429a06db4">&#9670;&nbsp;</a></span>previous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classtket_1_1VectorListHybrid.html">VectorListHybrid</a>&lt; T &gt;::<a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a> &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">ID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like next. </p>
<p>Get the element ID before the given one (which MUST be valid), or a null ID if we're already at the front. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of an existing element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the element before it (towards the FRONT), or null if it doesn't exist. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00437">437</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="ad6ff36bbb8c4eae1a5c3c61b33808da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6ff36bbb8c4eae1a5c3c61b33808da2">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exactly like std::vector push_back. </p>
<p>Fine if T is lightweight. Otherwise, maybe better to reuse elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The T object to be copied and stored. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00342">342</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a2522b963937f4cc2f9ccf5564fd31660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2522b963937f4cc2f9ccf5564fd31660">&#9670;&nbsp;</a></span>push_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like push_back, but instead inserts the new element before the existing front element (so that it becomes the new front). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The T object to be copied and stored. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00363">363</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a3a7451fe6504b746702e88d1fdbb3264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7451fe6504b746702e88d1fdbb3264">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::reverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like std::reverse, reverses the (logical) order of the elements. </p>
<p>(Not the physical order: the internal vector of T objects is unchanged, only the links are changed). Existing ids may be invalidated. Time O(n). </p>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00328">328</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="add329e55d8d33d42b9a979d541b68498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add329e55d8d33d42b9a979d541b68498">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of valid elements stored (not, of course, the actual internal number of elements, which is larger if some are waiting to be reused). </p>
<dl class="section return"><dt>Returns</dt><dd>The number of active elements stored. </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00337">337</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<a id="a68aa252191d79bc46ae98febb7c9c9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68aa252191d79bc46ae98febb7c9c9e2">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="classtket_1_1VectorListHybrid.html">tket::VectorListHybrid</a>&lt; T &gt;::to_vector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an ordinary vector of the data (in the correct order, maybe not the same as the internal storage order of course). </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the valid T objects stored, in the correct LOGICAL order, AS IF they had been inserted into a vector object throughout. (Of course, probably not the same as the actual storage order). </dd></dl>

<p class="definition">Definition at line <a class="el" href="VectorListHybrid_8hpp_source.html#l00507">507</a> of file <a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/TokenSwapping/include/TokenSwapping/<a class="el" href="VectorListHybrid_8hpp_source.html">VectorListHybrid.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
