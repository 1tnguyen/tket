<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tket: tket::tsa_internal::SwapListOptimiser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetket.html">tket</a></li><li class="navelem"><a class="el" href="namespacetket_1_1tsa__internal.html">tsa_internal</a></li><li class="navelem"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html">SwapListOptimiser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtket_1_1tsa__internal_1_1SwapListOptimiser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tket::tsa_internal::SwapListOptimiser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Can be reused, faster than constructing a new object.  
 <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SwapListOptimiser_8hpp_source.html">SwapListOptimiser.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abf4222221edc3c57275e23b211592738"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#abf4222221edc3c57275e23b211592738">ID</a> = <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">SwapList::ID</a></td></tr>
<tr class="separator:abf4222221edc3c57275e23b211592738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c4dfa3ca5a3c7a40a2cd40572d5b146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a4c4dfa3ca5a3c7a40a2cd40572d5b146">full_optimise</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list)</td></tr>
<tr class="memdesc:a4c4dfa3ca5a3c7a40a2cd40572d5b146"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slowest but most accurate end-to-end optimisation pass.  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a4c4dfa3ca5a3c7a40a2cd40572d5b146">More...</a><br /></td></tr>
<tr class="separator:a4c4dfa3ca5a3c7a40a2cd40572d5b146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32705e4e3ecf684bc0aa84b22c30123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#af32705e4e3ecf684bc0aa84b22c30123">full_optimise</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list, const <a class="el" href="namespacetket.html#a0469a9ea2fecfd89c9e1e0bc8611a140">VertexMapping</a> &amp;vertex_mapping)</td></tr>
<tr class="memdesc:af32705e4e3ecf684bc0aa84b22c30123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call when you also know the tokens.  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#af32705e4e3ecf684bc0aa84b22c30123">More...</a><br /></td></tr>
<tr class="separator:af32705e4e3ecf684bc0aa84b22c30123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21752fda65104fc277ff60e48cc97017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a21752fda65104fc277ff60e48cc97017">optimise_pass_with_zero_travel</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list)</td></tr>
<tr class="memdesc:a21752fda65104fc277ff60e48cc97017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not move any swaps, unless it cancels with a previous copy of itself (in which case, delete both).  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a21752fda65104fc277ff60e48cc97017">More...</a><br /></td></tr>
<tr class="separator:a21752fda65104fc277ff60e48cc97017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca6c02565f38cab73557a31efacb91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#adaca6c02565f38cab73557a31efacb91">optimise_pass_with_frontward_travel</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list)</td></tr>
<tr class="memdesc:adaca6c02565f38cab73557a31efacb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starting from the front and working along, every swap is moved as far towards the front as possible, until it hits a non-disjoint swap (so that it cannot pass through it; it doesn't commute), or an identical copy of itself (so that they cancel each other).  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#adaca6c02565f38cab73557a31efacb91">More...</a><br /></td></tr>
<tr class="separator:adaca6c02565f38cab73557a31efacb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986f6943781f9776ad44acc87b3eb32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a986f6943781f9776ad44acc87b3eb32e">optimise_pass_with_token_tracking</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list)</td></tr>
<tr class="memdesc:a986f6943781f9776ad44acc87b3eb32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase two swaps if they do the same TOKEN swap (which means that they can be removed).  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a986f6943781f9776ad44acc87b3eb32e">More...</a><br /></td></tr>
<tr class="separator:a986f6943781f9776ad44acc87b3eb32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f554d691e5a7229b0ac065d698cffaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a2f554d691e5a7229b0ac065d698cffaf">optimise_pass_remove_empty_swaps</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list, <a class="el" href="namespacetket.html#a0469a9ea2fecfd89c9e1e0bc8611a140">VertexMapping</a> vertex_mapping)</td></tr>
<tr class="memdesc:a2f554d691e5a7229b0ac065d698cffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">O(N log N): simply discard any swap between two empty tokens.  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a2f554d691e5a7229b0ac065d698cffaf">More...</a><br /></td></tr>
<tr class="separator:a2f554d691e5a7229b0ac065d698cffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a69f6f67903f0ba55fae88e26fa6df659"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a69f6f67903f0ba55fae88e26fa6df659">push_back</a> (<a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;list, const <a class="el" href="namespacetket.html#ae2eacf6ab35221f4acce2e51b150244a">Swap</a> &amp;swap)</td></tr>
<tr class="memdesc:a69f6f67903f0ba55fae88e26fa6df659"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most trivial O(1) optimisation: the new swap is added to the back, unless it equals the current last swap, in which case they cancel each other and are simply removed.  <a href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#a69f6f67903f0ba55fae88e26fa6df659">More...</a><br /></td></tr>
<tr class="separator:a69f6f67903f0ba55fae88e26fa6df659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Can be reused, faster than constructing a new object. </p>
<p>(This is intended: the final full algorithm may involve much random chopping and changing, simulated annealing, etc. and so call this many times). This is about directly optimising a list of swaps, knowing nothing about target vertices and tokens. Each optimisation pass may reorder the swaps and erase some, but always such that the resultant start-to-end vertex permutation is unchanged. (Thus, unmentioned swaps can never be added, because this class has no way of knowing if such swaps are possible). Thus this can convert bad solutions into better ones, but if our problem has some empty tokens, i.e. tokens with no target, which can end up anywhere, then algorithms will need that data to get good solutions. </p>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8hpp_source.html#l00037">37</a> of file <a class="el" href="SwapListOptimiser_8hpp_source.html">SwapListOptimiser.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abf4222221edc3c57275e23b211592738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4222221edc3c57275e23b211592738">&#9670;&nbsp;</a></span>ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtket_1_1tsa__internal_1_1SwapListOptimiser.html#abf4222221edc3c57275e23b211592738">tket::tsa_internal::SwapListOptimiser::ID</a> =  <a class="el" href="classtket_1_1VectorListHybrid.html#a8d32b7ccea8fb3974a036d113ec135d2">SwapList::ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8hpp_source.html#l00039">39</a> of file <a class="el" href="SwapListOptimiser_8hpp_source.html">SwapListOptimiser.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c4dfa3ca5a3c7a40a2cd40572d5b146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4dfa3ca5a3c7a40a2cd40572d5b146">&#9670;&nbsp;</a></span>full_optimise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::full_optimise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The slowest but most accurate end-to-end optimisation pass. </p>
<p>It will include other optimisation passes, so don't bother calling them also. This is possibly O(N^3.log N) in the worst case (but a clever proof might reduce this), but hopefully much faster in practice. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00274">274</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="af32705e4e3ecf684bc0aa84b22c30123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32705e4e3ecf684bc0aa84b22c30123">&#9670;&nbsp;</a></span>full_optimise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::full_optimise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#a0469a9ea2fecfd89c9e1e0bc8611a140">VertexMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call when you also know the tokens. </p>
<p>The slowest but hopefully best optimisation pass, which also removes empty swaps (swaps in which neither vertex has a token, so that they have no effect). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
    <tr><td class="paramname">vertex_mapping</td><td>The desired source-&gt;token mapping. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00281">281</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="a2f554d691e5a7229b0ac065d698cffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f554d691e5a7229b0ac065d698cffaf">&#9670;&nbsp;</a></span>optimise_pass_remove_empty_swaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::optimise_pass_remove_empty_swaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetket.html#a0469a9ea2fecfd89c9e1e0bc8611a140">VertexMapping</a>&#160;</td>
          <td class="paramname"><em>vertex_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>O(N log N): simply discard any swap between two empty tokens. </p>
<p>(Recall that optimise_pass_with_token_tracking does NOT know about these specific tokens, it creates internal artificial ones just for the pass. That pass can be much slower than this pass, but also can make some reductions which this pass cannot). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
    <tr><td class="paramname">vertex_mapping</td><td>The desired source-&gt;target mapping (so that we can determine which vertices have tokens on them). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00039">39</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="adaca6c02565f38cab73557a31efacb91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca6c02565f38cab73557a31efacb91">&#9670;&nbsp;</a></span>optimise_pass_with_frontward_travel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::optimise_pass_with_frontward_travel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starting from the front and working along, every swap is moved as far towards the front as possible, until it hits a non-disjoint swap (so that it cannot pass through it; it doesn't commute), or an identical copy of itself (so that they cancel each other). </p>
<p>The overall reduction should be the same as optimise_pass_with_zero_travel, which is cheaper (because swaps do not move), but interacting swaps should cluster together, which may be useful for certain algorithms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00172">172</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="a986f6943781f9776ad44acc87b3eb32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986f6943781f9776ad44acc87b3eb32e">&#9670;&nbsp;</a></span>optimise_pass_with_token_tracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::optimise_pass_with_token_tracking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase two swaps if they do the same TOKEN swap (which means that they can be removed). </p>
<p>Knows nothing about the problem-specific tokens, instead this creates artificial tokens. This is slower than optimise_pass_with_zero_travel and optimise_pass_with_frontward_travel, but is strictly more powerful (any reduction by those passes will also occur with this pass, but some additional reductions are possible with this pass. E.g., this pass reduces (01)(12)(01)(12)(01)(12), the cube of a 3-cycle, to zero swaps, which the other passes cannot, since (01) and (12) are not disjoint and hence cannot pass through each other). However, NOTE that this pass can introduce EMPTY swaps, w.r.t. the problem-specific tokens, so further passes to remove problem-specific empty token swaps are necessary to get the full reduction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00192">192</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="a21752fda65104fc277ff60e48cc97017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21752fda65104fc277ff60e48cc97017">&#9670;&nbsp;</a></span>optimise_pass_with_zero_travel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::optimise_pass_with_zero_travel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not move any swaps, unless it cancels with a previous copy of itself (in which case, delete both). </p>
<p>The fastest pass. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps to be optimised. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00121">121</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<a id="a69f6f67903f0ba55fae88e26fa6df659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f6f67903f0ba55fae88e26fa6df659">&#9670;&nbsp;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tket::tsa_internal::SwapListOptimiser::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetket.html#ae8a8548b749370f2d12478c8757ad439">SwapList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetket.html#ae2eacf6ab35221f4acce2e51b150244a">Swap</a> &amp;&#160;</td>
          <td class="paramname"><em>swap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The most trivial O(1) optimisation: the new swap is added to the back, unless it equals the current last swap, in which case they cancel each other and are simply removed. </p>
<p>However, all other optimisation passes also do this as a byproduct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The swaps. </td></tr>
    <tr><td class="paramname">swap</td><td>The single swap to be pushed back to the list (but adjacent equal swaps will be erased). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="SwapListOptimiser_8cpp_source.html#l00023">23</a> of file <a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/TokenSwapping/include/TokenSwapping/<a class="el" href="SwapListOptimiser_8hpp_source.html">SwapListOptimiser.hpp</a></li>
<li>src/TokenSwapping/<a class="el" href="SwapListOptimiser_8cpp_source.html">SwapListOptimiser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
