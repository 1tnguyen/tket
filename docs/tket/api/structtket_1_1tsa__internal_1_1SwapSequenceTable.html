<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tket: tket::tsa_internal::SwapSequenceTable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_CHTML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetket.html">tket</a></li><li class="navelem"><a class="el" href="namespacetket_1_1tsa__internal.html">tsa_internal</a></li><li class="navelem"><a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html">SwapSequenceTable</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structtket_1_1tsa__internal_1_1SwapSequenceTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tket::tsa_internal::SwapSequenceTable Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>For swaps on vertices {0,1,2,...,5}, return precomputed short swap sequences using given sets of edges.  
 <a href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SwapSequenceTable_8hpp_source.html">SwapSequenceTable.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ebcfc82cc79c5d42a1481790d816258"><td class="memItemLeft" align="right" valign="top">typedef std::uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5ebcfc82cc79c5d42a1481790d816258">Code</a></td></tr>
<tr class="memdesc:a5ebcfc82cc79c5d42a1481790d816258"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer type used to encode a swap sequence on vertices {0,1,2,3,4,5}.  <a href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5ebcfc82cc79c5d42a1481790d816258">More...</a><br /></td></tr>
<tr class="separator:a5ebcfc82cc79c5d42a1481790d816258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c474e7a981908a77be213026fe34943"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; unsigned, std::vector&lt; <a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5ebcfc82cc79c5d42a1481790d816258">Code</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5c474e7a981908a77be213026fe34943">Table</a></td></tr>
<tr class="memdesc:a5c474e7a981908a77be213026fe34943"><td class="mdescLeft">&#160;</td><td class="mdescRight">The KEY is a "permutation hash", i.e.  <a href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5c474e7a981908a77be213026fe34943">More...</a><br /></td></tr>
<tr class="separator:a5c474e7a981908a77be213026fe34943"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad1e27b57f37c7d310efafe34d48b9ba7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5c474e7a981908a77be213026fe34943">Table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#ad1e27b57f37c7d310efafe34d48b9ba7">get_table</a> ()</td></tr>
<tr class="memdesc:ad1e27b57f37c7d310efafe34d48b9ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual large precomputed table.  <a href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#ad1e27b57f37c7d310efafe34d48b9ba7">More...</a><br /></td></tr>
<tr class="separator:ad1e27b57f37c7d310efafe34d48b9ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>For swaps on vertices {0,1,2,...,5}, return precomputed short swap sequences using given sets of edges. </p>
<p>Should be close to optimal. (Every sequence should have the joint-shortest length amongst all sequences using those particular swaps, but not every possible sequence is included).</p>
<p>(The only possibility of non-optimality is that some solutions using many edges might be missing. It was constructed using breadth-first searches of all possible sequences up to certain depths on various graphs with &lt;= 6 vertices. Due to time/space limitations some non-complete graphs were searched as well as complete graphs K4, K5, K6.</p>
<p>Note that, by token tracking, any swap sequence of n vertices of length </p><blockquote class="doxtable">
<p>n(n-1)/2 can be reduced in length, so in fact any optimal swap sequence </p>
</blockquote>
<p>on n vertices has length &lt;= n(n-1)/2, the number of edges in the complete graph K(n).</p>
<p>Of course, ideally we'd search K6 up to depth 15, but searching up to depth 9 already consumed ~30 mins of CPU time and most of the memory capacity of an ordinary laptop. More efficient exhaustive search algorithms with clever pruning might cut it down a bit, but (since each added depth increases the difficulty roughly by a factor of 14) it would require significant computational effort to reach even depth 12 for K6, and depth 15 probably requires a supercomputer, or a very large distributed computation, or significantly more intelligent methods).</p>
<p>The table size is far smaller than the precomputation needed to create it. The creation considered millions of sequences, but the table has only a few thousand entries.</p>
<p>The table currently contains ALL optimal swap sequences on &lt;= 5 vertices, and also all swap sequences of length: &lt;= 9 on 6 vertices (K6, depth 9); &lt;= 12 on cycles with &lt;= 6 vertices (C5, C6); &lt;= 12 on a few other special graphs with 6 vertices.</p>
<p>Superficially redundant solutions have been removed:</p>
<p>(a): If sequences S1, S2 have equal length but the edges set E1 is a subset of E2, keep only S1, since every graph allowing S2 would also allow S1.</p>
<p>(b): If sequences S1, S2 have len(S1) &lt; len(S2), keep S2 exactly when E2 is NOT a subset of E1 (since, then there are graphs containing E2 which do NOT contain E1, so that S2 may be possible when S1 is impossible).</p>
<p>Finally, to save space, every sequence was checked before insertion, and inserted ONLY if its inverse was not already present in the table (since inverting permutations is trivial for swaps: just reverse the order). Hence, the table is only about half the size that it would otherwise be.</p>
<p>But, whilst these sequences are universally valid, this class knows nothing about HOW to look up results in the table efficiently. The current lookup algorithms are quite crude (but actually faster than fancier algorithms for this table size), but there is some possibility of speedup (although not result improvements) if a really fancy search/filtering algorithm can be found.</p>
<p>NOTE: the format is reasonable, but still not as compressed as possible; it still contains multiple isomorphic entries. A more complicated hashing scheme is required to cut down on these isomorphic copies. (E.g., perm hash 2, meaning the mapping 0-&gt;1, 1-&gt;0, i.e. (01), contains 0x262, 0x484, 0x737, meaning swap sequences [02 12 02], [04 14 04], [13 03 13]. It is easily seen that all 3 are isomorphic. The first two are of the form [ab cb ab] == [ac], and the third has the form [ab cb ab] == [ca].) It seems like we'd need a scheme involving integer hashing of graphs, with few isomorphic collisions, but such algoritms need to be pretty simple and fast or they're not worth doing except for much larger table sizes. </p>

<p class="definition">Definition at line <a class="el" href="SwapSequenceTable_8hpp_source.html#l00091">91</a> of file <a class="el" href="SwapSequenceTable_8hpp_source.html">SwapSequenceTable.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ebcfc82cc79c5d42a1481790d816258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebcfc82cc79c5d42a1481790d816258">&#9670;&nbsp;</a></span>Code</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::uint_fast64_t <a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5ebcfc82cc79c5d42a1481790d816258">tket::tsa_internal::SwapSequenceTable::Code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The integer type used to encode a swap sequence on vertices {0,1,2,3,4,5}. </p>

<p class="definition">Definition at line <a class="el" href="SwapSequenceTable_8hpp_source.html#l00094">94</a> of file <a class="el" href="SwapSequenceTable_8hpp_source.html">SwapSequenceTable.hpp</a>.</p>

</div>
</div>
<a id="a5c474e7a981908a77be213026fe34943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c474e7a981908a77be213026fe34943">&#9670;&nbsp;</a></span>Table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;unsigned, std::vector&lt;<a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5ebcfc82cc79c5d42a1481790d816258">Code</a>&gt; &gt; <a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5c474e7a981908a77be213026fe34943">tket::tsa_internal::SwapSequenceTable::Table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The KEY is a "permutation hash", i.e. </p>
<p>a number representing a permutation on {0,1,2,3,4,5}. (Not all possible permutations are represented, though; suitable vertex relabelling changes many different permutations to the same hash).</p>
<p>See <a class="el" href="CanonicalRelabelling_8hpp.html">CanonicalRelabelling.hpp</a>, <a class="el" href="SwapConversion_8hpp.html">SwapConversion.hpp</a> for more explanation.</p>
<p>The VALUE is a list of integers encoding a swap sequence, which all induce the permutation on {0,1,2,3,4,5} with the given hash. (Obviously, different sequences are allowed, because some swaps might not be possible, i.e. the graph might be incomplete). </p>

<p class="definition">Definition at line <a class="el" href="SwapSequenceTable_8hpp_source.html#l00108">108</a> of file <a class="el" href="SwapSequenceTable_8hpp_source.html">SwapSequenceTable.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1e27b57f37c7d310efafe34d48b9ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e27b57f37c7d310efafe34d48b9ba7">&#9670;&nbsp;</a></span>get_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtket_1_1tsa__internal_1_1SwapSequenceTable.html#a5c474e7a981908a77be213026fe34943">SwapSequenceTable::Table</a> tket::tsa_internal::SwapSequenceTable::get_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual large precomputed table. </p>
<p>The entries are already sorted and duplications/redundancies/suboptimality have been removed. However, currently this raw data is processed by <a class="el" href="classtket_1_1tsa__internal_1_1FilteredSwapSequences.html" title="Takes a raw list of integers, where each integer represents a swap sequence on the vertices {0,...">FilteredSwapSequences</a> which tolerates such imperfections. Thus it is easy to add more sequences to the table without worrying about them (as long as the newly added data is actually correct). </p><dl class="section return"><dt>Returns</dt><dd>A large precomputed raw table of data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="SwapSequenceTable_8cpp_source.html#l00020">20</a> of file <a class="el" href="SwapSequenceTable_8cpp_source.html">SwapSequenceTable.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>src/TokenSwapping/include/TokenSwapping/<a class="el" href="SwapSequenceTable_8hpp_source.html">SwapSequenceTable.hpp</a></li>
<li>src/TokenSwapping/TableLookup/<a class="el" href="SwapSequenceTable_8cpp_source.html">SwapSequenceTable.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
